
## 目前edit目录下：矩形、多边形支持的功能点：

### 矩形编辑器功能：

绘制、编辑（四角点拖拽）、撤销/重做、吸附、状态管理、图层显隐控制、几何有效性校验、样式配置

### 多边形编辑器功能：

绘制、编辑（顶点拖拽、中点插入、边拖拽、右键删除）、撤销/重做、吸附、图层显隐控制、状态管理、多环支持、几何有效性校验、样式配置



## 各几何图形功能规划（重构）
### 点
拖拽调整位置、吸附、撤销/重做、图层显隐控制、状态管理、样式配置

**第一轮分析（功能的合理性： 从功能的必要性，绘制行为、编辑行为等角度分析）**：
**点拖动**，可以做（但这个不是编辑行为）

**吸附**：绘制时支持吸附，拖动时支持吸附（不是编辑行为）。

**撤销重做**：用户绘制了一个点，然后发现自己绘制错了，可以撤销，重新绘制。（
Q: 那什么时候能完成绘制呢？ 除非提供一个按钮，点击表示完成绘制。
A: 去球吧~，没必要支持撤销重做，用户绘制错了，就把当前绘制的点删除，重新绘制就行了。
）

**图层显隐控制**：可做

**状态管理**：用户从绘制状态变成完成绘制状态。是必要的，可以做。

**样式配置**：必做


**第二轮分析(主要分析要不要放到BaseEditor中， 比如：BaseEditor中写抽象接口、方法、子类实现接口、方法。或者不应该放到BaseEditor中，由子类去写)**：
1. 拖动这个功能是不是点、线、面都应该有？ 答：应该是。应该抽到顶层（BaseEditor）中。
2. 吸附这个功能是不是点、线、面都应该有 或者说 编辑器是否应该提供吸附能力？ 答：我觉得应该是需要的，编辑器应该提供吸附能力吧？（抽到BaseEditor中）
3. 撤销重做这个功能目前看点是不需要的，（BaseEditor中写抽象方法，子类实现（点的实现逻辑直接return，或者提醒用户不可以撤销。））。
4. 状态管理：这个应该都需要，（抽到BaseEditor中）。
5. 样式配置：baseEditor中提供接口，子类实现。
6. 图层显隐控制：BaseEditor抽象，子类实现。（一般都是设置透明度做图层显隐吧？ 是的话，可以写在BaseEditor中实现）

### 线
顶点拖拽、中点插入、边拖拽、顶点删除、吸附、撤销/重做、校验、状态管理、图层显隐控制、样式配置

**第一轮分析（功能的合理性：从功能的必要性，绘制行为、编辑行为等角度分析）**：

**顶点拖拽**：对于编辑行为来说，是需要的。

**中点插入**：对于编辑行为来说，是需要的。

**边拖拽**：对于编辑行为来说，是需要的。

**顶点删除**：对于编辑行为来说，是需要的。

**吸附**：编辑和绘制时都需要。

**撤销重做**：编辑时需要，绘制时要支持撤销已经绘制的点，允许重绘。

**校验**：有的，是否允许自相交

**状态管理**：用户从绘制状态变成完成状态、从编辑状态到完成状态。是必要的，可以做。

**图层显隐控制**：可做

**样式配置**：必做


**第二轮分析(主要分析要不要放到BaseEditor中， 比如：BaseEditor中写抽象接口、方法、子类实现接口、方法。或者不应该放到BaseEditor中，由子类去写)**：
1. 对于顶点： 无论点、线、面都有顶点，对于顶点的编辑行为，应该抽到BaseEditor中。
2. 对于中点、边拖拽：矩形一般是没必要的，圆也没必要。非通用部分抽离到基类（xxxShapeEditor）中。
3. 顶点删除：编辑状态下：对于点来说，至少保留1个点，对于线来说，至少保留2个点，对于面来说，至少保留3个点。（放BaseEditor抽象类中吧）
4. 吸附：编辑和绘制时都需要，放到BaseEditor抽象类中。
5. 撤销重做：编辑时需要，绘制时要支持撤销已经绘制的点，允许重绘（对于一个编辑器来说，应该是必须的，放到BaseEditor抽象类中）。
6. 校验：有的（放到BaseEditor抽象类中，不过每种类型的几何图层的校验规则、数量并不一致，baseEditor中只提供一个校验接口，子类实现校验逻辑）
7. 状态管理：用户从绘制状态变成完成状态、从编辑状态到完成状态。是必要的（放到BaseEditor抽象类中）。
8. 样式配置：baseEditor中提供接口，子类实现。
9. 图层显隐控制：BaseEditor抽象，子类实现（一般都是设置透明度做图层显隐吧？ 是的话，可以写在BaseEditor中实现）
   
### 圆
圆心拖拽、半径调整、吸附、撤销/重做、图层显隐控制、校验、样式配置

**第一轮分析（功能的合理性：从功能的必要性，绘制行为、编辑行为等角度分析）**：
现阶段圆形的geojson返回结果是使用turf.js的circle方法生成的，这会影响绘制行为和编辑行为，需要考虑下怎么调整。
1. 圆心拖拽：❌ 这是编辑时候的操作？好奇怪，怎么实现？
2. 半径调整：这是应该是编辑时候的操作 怎么实现？（能想到的渲染圆心，渲染边上的任意一点，设置编辑状态等）
3. 吸附：最多支持个圆心吸附和拖动位置的吸附吧？
4. 图层显隐控制：可做，
5. 撤销重做：emmm...
6. 校验: 支持提供最小圆的半径，小于用户设置的值，则不允许结束绘制。
7. 样式配置：必做

**第二轮分析(主要分析要不要放到BaseEditor中， 比如：BaseEditor中写抽象接口、方法、子类实现接口、方法。或者不应该放到BaseEditor中，由子类去写)**：
1. 圆心拖拽：❌
2. 半径调整：基类（circleShapeEditor）
3. 吸附：（放到baseEditor中）
4. 图层显隐控制：BaseEditor抽象，子类实现（一般都是设置透明度做图层显隐吧？ 是的话，可以写在BaseEditor中实现）
5. 撤销重做：（baseEditor做抽象，子类实现）
6. 校验：（baseEditor做接口抽象，子类实现）
7. 样式配置：（baseEditor做接口抽象，子类实现）

### 矩形
绘制、编辑（四角点拖拽）、撤销/重做、吸附、状态管理、图层显隐控制、几何有效性校验、样式配置
可选增加中点插入和边拖拽

**第一轮分析（功能的合理性：从功能的必要性，绘制行为、编辑行为等角度分析）**：
1. 绘制： 做了
2. 编辑（四角点拖拽）： 做了
3. 撤销重做： 做了
4. 吸附： 做了
5. 状态管理： 做了
6. 图层显隐控制： 做了
7. 几何有效性校验： 做了
8. 样式配置： 做了
9. 中点插入： 先不加
10. 边拖拽： 先不加
**第二轮分析(主要分析要不要放到BaseEditor中， 比如：BaseEditor中写抽象接口、方法、子类实现接口、方法。或者不应该放到BaseEditor中，由子类去写)**：
1. 绘制： 绘制就得有layer，放到BaseEditor中做抽象，子类实现。
2. 编辑（四角点拖拽）： 也就是顶点拖动，放到BaseEditor中实现。
3. 撤销重做： baseEditor做抽象，子类实现。
4. 吸附： BaseEditor实现。
5. 状态管理： BaseEditor实现
6. 图层显隐控制： BaseEditor抽象，子类实现（一般都是设置透明度做图层显隐吧？ 是的话，可以写在BaseEditor中实现）
7. 几何有效性校验： BaseEditor做抽象接口，子类实现各自的几何校验
8. 样式配置： BaseEditor做抽象接口，子类实现各自的样式配置
9. 中点插入： （baseEditor做抽象，子类实现）
10. 边拖拽： （baseEditor做抽象，子类实现）

### 多边形

绘制、编辑（顶点拖拽、中点插入、边拖拽、右键删除）、撤销/重做、吸附、图层显隐控制、状态管理、多环支持、几何有效性校验、样式配置

**第一轮分析（功能的合理性：从功能的必要性，绘制行为、编辑行为等角度分析）**：
功能都做了

**第二轮分析(主要分析要不要放到BaseEditor中， 比如：BaseEditor中写抽象接口、方法、子类实现接口、方法。或者不应该放到BaseEditor中，由子类去写)**：
1. 绘制： 绘制就得有layer，放到BaseEditor中做layer抽象，子类实现样式， 图层的事件也在BaseEditor中抽象，子类实现。
2. 编辑（顶点拖动、中点插入、边拖拽、右键删除）：顶点的拖动、右键删除可以放到BaseEditor中实现，中点插入、边拖拽放到子类中实现。
3. 撤销/重做： baseEditor做抽象，子类实现。
4. 吸附： BaseEditor实现。
5. 图层显隐控制： BaseEditor抽象，子类实现（一般都是设置透明度做图层显隐吧？ 是的话，可以写在BaseEditor中实现）
6. 状态管理： BaseEditor实现
7. 多环支持： 这个是构造函数中--传入默认的geom--实现的，放BaseEditor中实现, 允许各种类型都支持传入默认的geom
8. 几何有效性校验： BaseEditor做抽象接口，子类实现各自的几何校验
9. 样式配置： BaseEditor做抽象接口，子类实现各自的样式配置



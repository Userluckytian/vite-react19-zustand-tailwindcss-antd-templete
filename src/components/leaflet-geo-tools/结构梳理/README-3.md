基于README-2.md, 接下来要梳理各个文件中应该包含的内容：

1. BaseEditor.ts（我期望别人继承我时，应该要知道自己应该去实现哪些内容）
- 定义抽象类BaseEditor，作为编辑器，我应该具备：
- 0：吸附功能，实例化编辑器时，要传递
- 1：第一步我们先只考虑绘制行为（撤销重绘，样式配置，吸附到其他图层、图层显隐控制、）：
- 2：我们需要一个图层layer，它应该是一个实体对象。  
- 3：需要提供一个createLayer方法，创建这个图层对象（但是每个类型的不同，所以这个使用抽象的，由各个子类自行实现。这里涉及图层的style样式，写在子类中吧。）
- 4：我们绘制时还需要做点击、鼠标移动，双击事件（bindMapEvents），但是每个几何类型的事件可能不完全一致，所以这个使用抽象的，由各个子类自行实现。同样的，关闭监听的事件offMapEvents方法也是抽象的，由子类具体实现。
- 5：作为一个编辑器，那么可能需要提供隐藏或者展示图层的功能（但是不同几何类型又可能不同，所以这个使用抽象的（setLayerVisibility），在子类中具体实现）。同时应该提供一个方法，用于获取当前图层的状态（getLayerVisible）。
- 6：更新图层的样式（updateLayer）是非必须的，放在子类中自己去写吧。
- 7：用户绘制完成后，可能需要获取这个图层的geojson数据（getGeoJson），但是每种几何类型的获取方式不一定一致。所以这个方法也是抽象的，由子类具体实现。（后续发现一致的话可以调整）
- 8：从创建图层-->添加到地图-->更新样式-->获取geojson-->销毁图层，这个过程是完整的了。下一步考虑编辑行为：
- 编辑行为包括：双击激活编辑（enterEditMode，配套方法exitEditMode（抽象方法）），进入编辑模式后，会涉及顶点的渲染、拖动、添加和删除、撤销/重做等操作（这些子类实现enterEditMode方法时来实现）
- 
- 9：需要提供一个getLayer方法，返回这个图层对象。这个是实体函数即可。
  10：几何有效性校验，要不写在子类中？（每种类型的校验规则不一样，baseEditor中只提供一个校验接口，子类实现校验逻辑）

  11：状态管理：用户从绘制状态变成完成状态、从编辑状态到完成状态。是必要的（放到BaseEditor抽象类中）。

  12：销毁编辑器：destroy方法，销毁图层，关闭事件监听，销毁编辑器实例等（放到BaseEditor抽象类中实现）
  

1. 
<!-- 不再需要！下面是废话 -->
`InteractionModeManager.ts` 是状态源（负责存储和广播当前模式）
`drawToolbarController.ts` 是行为触发器（负责设置模式并调用对应功能）

#### 解释其作用:

1. 我们先不考虑draw目录下的内容，仅关注edit目录下的polygon.ts文件，因为这个文件已经包含了绘制的逻辑和编辑的逻辑了。现在我们要干嘛？答： 增加拓扑逻辑。同时我们计划：分成三个工具条： 绘制工具条、编辑工具条、拓扑工具条。
2. 然后用户点击绘制工具条的绘制面按钮，开始绘制多边形。首先是点击操作，它触发了事件`setCurrSelTool`,那么`currSelTool`就有值了。
```javascript
    const [currSelTool, setCurrSelTool] = useState<string | null>(null); // 当前使用的【绘制条上的绘制工具】
```
3. 然后用户绘制完成后，会设置`currSelTool`的值为空字符串， 然后用户双击图形，打开了编辑工具条，这个操作触发了事件`setCurrEditLayer`,那么`currEditLayer`就有值了。
```javascript
    const [currEditLayer, setCurrEditLayer] = useState<any>(null); // 当前编辑的图层【我们设置的是一次仅可编辑一个图层】
```
3. 等用户编辑完成，点击【完成】按钮，那么`currEditLayer`的值就为null了。
4. 接下来，我们要触发topo操作了，那么请问，topo的操作是不是： `currEditLayer`的值为null，且`currSelTool`的值为空字符串时，才可以进行topo操作？
5. 好，那接下来我们开始编写topo的逻辑代码，比如选择操作，首先这个操作是用户点击了选择按钮触发的，针对绘制操作，绘制的状态也是用户点击按钮触发的，针对编辑操作也是用户双击图形然后触发的。触发了，所以我们知道状态改变了。但是这些状态你让用户自己去维护吗？
6. 为了解决：不让用户去维护这些状态，我们需要调整下我们的代码，举个例子，假设用户点击绘制面操作，实际执行的操作是：`drawManager.startPolygon()`, 那我们就需要增加中间处理层，来管理这些状态，这个处理层我们可以称之为行为触发器层（ActionController.ts），根据下面代码的写法来做的话，用户不需要关心状态管理细节，状态还是由我们来管理。用户正常使用绘制操作即可，不用关心状态是怎么变化的
```javascript ActionController.ts
    function newStartPolygon() {
    modeManager.setMode('draw');
    drawManager.startPolygon();
    }
```


——————————————————————

1. 用户先获取到选中的图层，组件这边提供高亮捕获的图层
2. 用户点击裁剪按钮--触发绘制线事件
3. 绘制完毕后，我执行结果计算，然后只将geojson数据抛出去。
4. 用户自己做业务逻辑（比如删除旧图层，新建新的图层）。
5. ————————————————————————
6. 允许回退、撤销、重做。









<!--
吸附原理部分： 
1：吸附源是谁? 
答： 假设图上有abc三个几何图形，然后你此刻在编辑C几何图层，那么吸附源就是除去C几何图层外的其他两个图层A和B。比如A和B均是多边形，我要先收集A和B的全部顶点。以拖动C几何中的一个顶点p1为例，我就要把P1和AB图层的所有顶点进行比较，来判断吸附到谁身上。综上: 吸附源是【A和B的全部顶点】。
对于数据格式，我们可以提前整理出一个处理好的拆分数据，比如：
// 线/面的抽象表示
const draggedGeometry = {
  type: 'polygon', // 或 'polyline'
  vertices: [p1, p2, p3, p4], // 所有顶点
  edges: [         // 所有边（线段）
    {start: p1, end: p2},
    {start: p2, end: p3},
    // ...
  ],
  bounds: {minX, minY, maxX, maxY}, // 包围盒
};

2：针对线的吸附呢？ 比如我拖动C的一条线或者拖动C整个面，如何实现吸附？
答：针对面拖动，我们可以认为是多条线的拖动，所以可以参考拖动一条线的方法。
拖动图层 C 的一条边（线段），其他图层A、B是面
1：我拖动的是一条边 E = [P₁, P₂]。
2：吸附源是其他图层（A、B）的边集合 E' = {[A₁, A₂], [B₁, B₂], ...}。
3：对每一对边执行什么判断？ 有没有边对边的处理方法?

方法1:平行边投影吸附 （应用场景：1：拖动面时希望边缘与其他图形边缘对齐（如拼图、地块拼接）2：编辑建筑、地籍、规划图等需要边线对齐的场景）
    3.1.1. 判断E与E'是否近似平行（允许小误差）,平行则继续
    3.1.2. 计算P1到E'线的距离d1，P2到E'线的距离d2
    3.1.3. 计算平均距离 d_avg = (d1 + d2) / 2
    3.1.4. 如果 d_avg < 阈值 → 吸附
    3.1.5. 吸附时：将E整条边平行移动到E'上

方法2：端点延伸吸附 （应用场景：1：拖动顶点时希望“对齐到一条延长线”上 2：适合道路、管线、建筑轮廓等“延伸对齐”的需求）
start
    如果 直线L与L'相交于I:
        如果 I在E的合理延长范围内:
            如果 I到E'线段的距离 < 阈值:
                计算偏移量 offset = I - E的端点
                将E整体平移offset
end

3：优化：
地图编辑中可能有大量几何元素，需要优化, 只在拖动点周围查询

4：汇总全部需求：
1： 我是否应该构建一个独立的ts文件。
2: 后续我想在页面放置按钮：1：开启吸附、关闭吸附 2：吸附方式: 顶点吸附、线吸附。针对2我不确定应该是自动判断还是让用户选择
3:对于数据格式，我们可以提前整理出一个处理好的拆分数据，比如：
// 线/面的抽象表示
const draggedGeometry = {
  type: 'polygon', // 或 'polyline'
  vertices: [p1, p2, p3, p4], // 所有顶点
  edges: [         // 所有边（线段）
    {start: p1, end: p2},
    {start: p2, end: p3},
    // ...
  ],
  bounds: {minX, minY, maxX, maxY}, // 包围盒(这个是否需要),
geometry: {...}
};
4:地图编辑中可能有大量几何元素，需要优化, 只在拖动点周围查询
5: 对于顶点吸附：以拖动C几何中的一个顶点p1为例，我就要把从周围获取的顶点都进行比较，来判断吸附到谁身上
6：对于线吸附：采用平行边投影吸附 
    6.1：我拖动的是一条边 E = [P₁, P₂]。
    6.2：吸附源是其他周围的边集合 E' = {[A₁, A₂], [B₁, B₂], ...}。
    6.3. 判断E与E'中每条边是否近似平行（允许小误差）,平行则继续
    6.4 计算P1到E'中平行线的距离d1，P2到E'线的距离d2
    6.5. 计算平均距离 d_avg = (d1 + d2) / 2
    6.6. 如果 d_avg < 阈值 → 吸附
    6.7. 吸附时：将E整条边平行移动到E'对应的平行边上

 -->